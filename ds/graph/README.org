* Graph
  Weighted directed graph implementation with adjacency matrix.

  Undirected graph is directed graph with 2-way edges.

  It requires some additional libraries:
  + Iterative DFS (not implemented): Stack
  + BFS: FIFO Queue
  + Dijsktra's algorithm: Priority Queue

* Topological sort
  ~python/toposort.py~

  1. DFS
  2. Sort vertices by reversed post-order

* Minimum spanning Tree (MST)
  1. Prim algorithm (~python/mst_prim.py~)
     Based on Dijkstra.

     Utilizes priority tree, grow by one edge each iteration.

     Refer: [[https://www.coursera.org/learn/algorithms-on-graphs][Algorithms on Graph]]: Prim algorithm.

  2. Kruskal algorithm (~python/mst_kruskal.py~)
     Repeatedly add lightest edge that doesn't produce a cycle.

     Adapts union's quick find to check for connectivity.

     Refer: [[https://www.coursera.org/learn/algorithms-on-graphs][Algorithms on Graph]]: Kruskal algorithm.

* Strongly connected components
  Reverse the graph and then topological sort to find the sinks (which are the sources of the original graph).
  For each source in the original graph, explore (DFS) to group connected vertices.

  Refer: [[https://www.coursera.org/learn/algorithms-on-graphs][Algorithms on Graph]]: Strongly connected components.

* Shortest paths
*** Dijkstra's algorithm
    Only works with non-negative weights.
    Ref: [[https://rosettacode.org/wiki/Dijkstra%27s_algorithm#C][Rosetta Code]]

*** Bellman-Ford
    Can work with negative weights.
    Ref: [[https://cp-algorithms.com/graph/bellman_ford.html][cp-algorithms]]
